#ifndef __SBIF_H__
#define __SBIF_H__

#include <stdint.h>
#include <iostream>
#include "sbif_config.h"
#include "brahma.h"

// all sizes in bytes
#define SBIF_WORD_SIZE  (sizeof(sbif_word_t))
#define SBIF_LINE_SIZE  (sizeof(sbif_line_t))
#define SBIF_MSG_SIZE   (SBIF_LINE_SIZE)

// get the minimum burst length.
// line_size will always be a multiple of word_size.
// Otherwise, the interface logic becomes complex for no reason
#define SBIF_MIN_BURST  (SBIF_LINE_SIZE/SBIF_WORD_SIZE)

/**
* SBIF Control Port:
*   contains the control information.
*   TX:
*     write_readn - determines whether the request is a read or a write.
*     page_id     - this is the pointer ID that would have been shared.
*     line_offset - which line to view in the page.
*     num_lines   - how many lines (messages) to read
*   RX:
*     ack         - acknowledgement from peer TX that a message is read.
*     sb_response - response from the SB about malloc/free requests
*
* @todo:
*   * Let the user instantiate the entire struct, but warn about unused
*     RX/TX ports if the task is only producing/consuming.
*/
typedef struct
{
  union {
    bool          write_readn;
    uint8_t       num_lines;
  }task_request;
  sbif_pageid_t page_id;
  sbif_index_t  line_offset;
}ctx_t;
typedef struct
{
  bool          ack;
  sbif_word_t   sb_response;
}crx_t;
typedef struct
{
  void* ctx_p;
  void* crx_p;
}sbif_ctrl_t;

typedef struct
{
  void* dtx_p;
  void* drx_p;
  sbif_msg_t data;
}sbif_data_t;


/**
 * Each Heap interface provides two 'ports':
 * Controlone each for read and write. This is done because the routing for the
 * read and write interfaces might require placement in different regions
 * of the PE's floorplan, especially if the PE is involved in heavy
 * dataflow.
 * Keeping the memory port functionality split like this offers two benefits:
 *  1. Allows the PE to have different 'interface heads'
 *  2. A PE that only does one type of I/O operation defines only one port
 *      and hence saves resources.
*/
template <typename _sbif_msg_t, sbif_depth_t _tx_depth, sbif_depth_t _rx_depth>
class SBIF {
private:
  constexpr static sbif_depth_t tx_depth = _tx_depth;
  constexpr static sbif_depth_t rx_depth = _rx_depth;
  _sbif_msg_t tx_msgs[tx_depth];
  _sbif_msg_t rx_msgs[rx_depth];
  sbif_data_t* sbif_data_p;
  sbif_ctrl_t* sbif_ctrl_p;

public:
  using dstream_t = tapa::stream<sbif_msg_t>;
  using ctxstream_t = tapa::stream<ctx_t>;
  using crxstream_t = tapa::stream<crx_t>;

  // constructor
  SBIF() {
    // create the data streams - 1 each for TX/RX
    dstream_t* _dtx_p = new dstream_t;
    dstream_t* _drx_p = new dstream_t;
    sbif_data_p->dtx_p = static_cast<void*>(_dtx_p);
    sbif_data_p->drx_p = static_cast<void*>(_drx_p);

    // create the control streams - 1 each for TX/RX
    ctxstream_t* _ctx_p = new ctxstream_t;
    crxstream_t* _crx_p = new crxstream_t;
    sbif_ctrl_p->ctx_p = static_cast<void*>(_ctx_p);
    sbif_ctrl_p->crx_p = static_cast<void*>(_crx_p);

    print_config();
  }

  /////////////////////////////////////////////////////////////////////////////

  void print_config()
  {
    std::cout << "init heap i/f" << std::endl;
    std::cout << "TX Depth: " << (unsigned)tx_depth << std::endl;
    std::cout << "RX Depth: " << (unsigned)rx_depth << std::endl;
  }

  sbif_depth_t get_tx_depth()
  {
    return tx_depth;
  }

  sbif_depth_t get_rx_depth()
  {
    return rx_depth;
  }

  // sbif_msg_t

};


#endif // __SBIF_H__
